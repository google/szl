# Copyright 2010 Google Inc.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ------------------------------------------------------------------------

# a couple of proto definitions: we use myproto0 as
# the base, and then define several successor protos
# with various fields missing so we can get the
# corresponding bytes for conversion
type myproto0 = {
  x: int = 42 @ 1,
  y: float = 3.1415 @ 2,
  t: time @ 3,
  b: bytes = {} @ 5,  # here we should get a warning
  z: bool = true @ 6,
  p: { x: int = 21 @ 8,
       y: float = 2.718 @ 9 } @ 10
};

type myproto1 = {
  # x: int = 42 @ 1,
  y: float = 3.1415 @ 2,
  t: time @ 3,
  b: bytes = {} @ 5,  # here we should get a warning
  z: bool = true @ 6,
  p: { x: int = 21 @ 8,
       y: float = 2.718 @ 9 } @ 10
};

type myproto2 = {
  # x: int = 42 @ 1,
  # y: float = 3.1415 @ 2,
  t: time @ 3,
  b: bytes = {} @ 5,  # here we should get a warning
  z: bool = true @ 6,
  # p: { x: int = 21 @ 8,
  #      y: float = 2.718 @ 9 } @ 10
};

type myproto3 = {
  # x: int = 42 @ 1,
  # y: float = 3.1415 @ 2,
  # t: time @ 3,
  b: bytes = {} @ 5,  # here we should get a warning
  z: bool = true @ 6,
  # p: { x: int = 21 @ 8,
  #      y: float = 2.718 @ 9 } @ 10
};

type myproto4 = {
  # x: int = 42 @ 1
  # y: float = 3.1415 @ 2,
  # t: time @ 3,
  # b: bytes = {} @ 5,  # here we should get a warning
  z: bool = true @ 6,
  p: { # x: int = 21 @ 8,
       y: float = 2.718 @ 9 } @ 10
};


type myproto5 = {
  x: int = 42 @ 1,
  # y: float = 3.1415 @ 2,
  # t: time @ 3,
  # b: bytes = {} @ 5,  # here we should get a warning
  # z: bool = true @ 6,
  p: { x: int = 21 @ 8,
       # y: float = 2.718 @ 9 
     } @ 10
};


# a value for each proto type
p0: myproto0 = { 24, 5141.3, time(0xfffffffffff), {1, 2, 3}, false, 
                 { -5, -1.2 } };
p1: myproto1 = { 5141.3, time(0xfffffffffff), {1, 2, 3}, false, { -5, -1.2 } };
p2: myproto2 = { time(0xfffffffffff), {1, 2, 3}, false };
p3: myproto3 = { {1, 2, 3}, false };
p4: myproto4 = { false, { -1.2 } };
p5: myproto5 = { 24, { -5 } };


# get the bytes for each of the proto values

assert(string(bytes(p0), "hex") == "081811cdcccccc4c15b44019ffffffffff0f00002a0301020330005340fbffffffffffffffff0149333333333333f3bf54");
assert(string(bytes(p1), "hex") == "11cdcccccc4c15b44019ffffffffff0f00002a0301020330005340fbffffffffffffffff0149333333333333f3bf54");
assert(string(bytes(p2), "hex") == "19ffffffffff0f00002a030102033000");
assert(string(bytes(p3), "hex") == "2a030102033000");
assert(string(bytes(p4), "hex") == "30005349333333333333f3bf54");
assert(string(bytes(p5), "hex") == "08185340fbffffffffffffffff0154");


# the following 5 lines are generated by the previous 5 lines...
b0: bytes = bytes("09180000000000000011cdcccccc4c15b44019ffffffffff0f00002a0301020330005341fbffffffffffffff49333333333333f3bf54", "hex");
b1: bytes = bytes("11cdcccccc4c15b44019ffffffffff0f00002a0301020330005341fbffffffffffffff49333333333333f3bf54", "hex");
b2: bytes = bytes("19ffffffffff0f00002a030102033000", "hex");
b3: bytes = bytes("2a030102033000", "hex");
b4: bytes = bytes("30005349333333333333f3bf54", "hex");
b5: bytes = bytes("0918000000000000005341fbffffffffffffff54", "hex");

# convert all 'input' protos into myproto0 - conversion
# should automatically fill in the missing fields
q0: myproto0 = b0;
q1: myproto0 = b1;
q2: myproto0 = b2;
q3: myproto0 = b3;
q4: myproto0 = b4;
q5: myproto0 = b5;


# print the proto tuples - verify the output
assert(string(p0) == `{ 24, 5141.3, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { -5, -1.2 } }`);
assert(string(q0) == `{ 24, 5141.3, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { -5, -1.2 } }`);

assert(string(p1) == `{ 5141.3, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { -5, -1.2 } }`);
assert(string(q1) == `{ 42, 5141.3, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { -5, -1.2 } }`);

assert(string(p2) == `{ "Thu Jul 23 07:43:06 PDT 1970", X"010203", false }`);
assert(string(q2) == `{ 42, 3.1415, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { 21, 2.718 } }`);

assert(string(p3) == `{ X"010203", false }`);
assert(string(q3) == `{ 42, 3.1415, "Wed Dec 31 16:00:00 PST 1969", X"010203", false, { 21, 2.718 } }`);

assert(string(p4) == `{ false, { -1.2 } }`);
assert(string(q4) == `{ 42, 3.1415, "Wed Dec 31 16:00:00 PST 1969", B"", false, { 21, -1.2 } }`);

assert(string(p5) == `{ 24, { -5 } }`);
assert(string(q5) == `{ 24, 3.1415, "Wed Dec 31 16:00:00 PST 1969", B"", true, { -5, 2.718 } }`);

# try altering some values
q1.x = 41;
q2.y = 0.005;
q2.p.x = 1;
q4.p.y = -5.1;
q5.p.y = -6.1;

# check that altering one proto doesn't affect the values of the other protos
assert(string(q0) == `{ 24, 5141.3, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { -5, -1.2 } }`);
assert(string(q1) == `{ 41, 5141.3, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { -5, -1.2 } }`);
assert(string(q2) == `{ 42, 0.005, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { 1, 2.718 } }`);
assert(string(q3) == `{ 42, 3.1415, "Wed Dec 31 16:00:00 PST 1969", X"010203", false, { 21, 2.718 } }`);
assert(string(q4) == `{ 42, 3.1415, "Wed Dec 31 16:00:00 PST 1969", B"", false, { 21, -5.1 } }`);
assert(string(q5) == `{ 24, 3.1415, "Wed Dec 31 16:00:00 PST 1969", B"", true, { -5, -6.1 } }`);

# also check that proto conversion isn't corrupted
r0: myproto0 = b0;
r1: myproto0 = b1;
r2: myproto0 = b2;
r3: myproto0 = b3;
r4: myproto0 = b4;
r5: myproto0 = b5;
assert(string(r0) == `{ 24, 5141.3, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { -5, -1.2 } }`);
assert(string(r1) == `{ 42, 5141.3, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { -5, -1.2 } }`);
assert(string(r2) == `{ 42, 3.1415, "Thu Jul 23 07:43:06 PDT 1970", X"010203", false, { 21, 2.718 } }`);
assert(string(r3) == `{ 42, 3.1415, "Wed Dec 31 16:00:00 PST 1969", X"010203", false, { 21, 2.718 } }`);
assert(string(r4) == `{ 42, 3.1415, "Wed Dec 31 16:00:00 PST 1969", B"", false, { 21, -1.2 } }`);
assert(string(r5) == `{ 24, 3.1415, "Wed Dec 31 16:00:00 PST 1969", B"", true, { -5, 2.718 } }`);

# Appending a regression test.  Tuples compared by == or != should have
# all of their fields referenced and decoded from byte strings.

# The bug was that a mere == or != expression involving a tuple did not cause
# the tuple's fields to be used.  In order to test both == and !=, we need two
# distinct types that don't share fields, so we use two structurally identical
# types containing a subset of fields from another test case.
type TestEQ = parsedmessage {
  type Proto1Message = parsedmessage {
    type NestedMessage = parsedmessage {
      a: int @ 1 : int64,
      b: int @ 2 : fixed32,
      c: int @ 3 : fixed32
    },

    value: TestEQ.Proto1Message.NestedMessage @ 4,
  },
  type Message2 = {
    message1: TestEQ.Proto1Message @ 1
  },
  item: array of TestEQ.Message2 @ 2
};

type TestNE = proto {
  type Proto1Message = proto {
    type NestedMessage = proto {
      a: int @ 1 : int64,
      b: int @ 2 : fixed32,
      c: int @ 3 : fixed32
    },

    value: TestNE.Proto1Message.NestedMessage @ 4,
  },

  type Message2 = {
    message1: TestNE.Proto1Message @ 1
  },
  item: array of TestNE.Message2 @ 2
};

# The byte string below encodes the following object with two distinct
# items.  A bug in treatment of the equality operator makes causes
# Sawzall to say that the items are equal.
#
# value1: Test*.Proto1Message.NestedMessage = { 13, 26, 39 };
# entry1: Test*.Proto1Message = { value1 };
#
# value2: Test*.Proto1Message.NestedMessage = { 17, 34, 51 };
# entry2: Test*.Proto1Message = { value2 };
#
# item: array of Test*.Message2 = { { entry1 }, { entry2 } };
#
# object: Test* = { item };

object_bytes: bytes =
    X"130a0e220c080d151a0000001d2700000014130a0e220c081115220000001d3300000014";

# Test for operator ==.

object_eq: TestEQ = object_bytes;

# The values should not be equal, but they are if all fields are unused.
assert(!(object_eq.item[0].message1.value ==
         object_eq.item[1].message1.value),
       "Tuples should not be equal");


# Test for !=.

object_ne: TestNE = object_bytes;

# The values should not be equal, but they are if all fields are unused.
assert(object_ne.item[0].message1.value !=
       object_ne.item[1].message1.value,
       "Tuples should not be equal");
